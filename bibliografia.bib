@inproceedings{Marek:2012:DDL:2162049.2162077,
 author = {Marek, Luk\'{a}\v{s} and Villaz\'{o}n, Alex and Zheng, Yudi and Ansaloni, Danilo and Binder, Walter and Qi, Zhengwei},
 title = {DiSL: A Domain-specific Language for Bytecode Instrumentation},
 booktitle = {Proceedings of the 11th Annual International Conference on Aspect-oriented Software Development},
 series = {AOSD '12},
 year = {2012},
 isbn = {978-1-4503-1092-5},
 location = {Potsdam, Germany},
 pages = {239--250},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/2162049.2162077},
 doi = {10.1145/2162049.2162077},
 acmid = {2162077},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {JVM, aspect-oriented programming, bytecode instrumentation, dynamic program analysis},
}

@InProceedings{10.1007/978-3-642-35182-2_18,
author="Marek, Luk{\'a}{\v{s}} and Zheng, Yudi and Ansaloni, Danilo and Sarimbekov, Aibek and Binder, Walter and T{\r{u}}ma, Petr and Qi, Zhengwei",
editor="Jhala, Ranjit and Igarashi, Atsushi",
title="Java Bytecode Instrumentation Made Easy: The DiSL Framework for Dynamic Program Analysis",
booktitle="Programming Languages and Systems",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="256--263",
abstract="Many software development tools (e.g., profilers, debuggers, testing tools) and frameworks (e.g., aspect weavers) are based on bytecode instrumentation techniques. While there are many low-level bytecode manipulation libraries that support the development of such tools and frameworks, they typically provide only low-level abstractions and require detailed knowledge of the Java Virtual Machine. In addition, they often lack the necessary infrastructure for load-time instrumentation with complete bytecode coverage to ensure that each method with a bytecode representation gets instrumented. In this paper we give an introduction to DiSL, a domain-specific aspect language and framework for bytecode instrumentation that reconciles high expressiveness of the language, high level of abstraction, and efficiency of the generated code. We illustrate the strengths of DiSL with a concrete analysis as a case study. The DiSL framework is open-source and has been successfully used in several research projects.",
isbn="978-3-642-35182-2"
}

@inproceedings{Handley:2018:ACT:3242744.3242749,
 author = {Handley, Martin A. T. and Hutton, Graham},
 title = {AutoBench: Comparing the Time Performance of Haskell Programs},
 booktitle = {Proceedings of the 11th ACM SIGPLAN International Symposium on Haskell},
 series = {Haskell 2018},
 year = {2018},
 isbn = {978-1-4503-5835-4},
 location = {St. Louis, MO, USA},
 pages = {26--37},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/3242744.3242749},
 doi = {10.1145/3242744.3242749},
 acmid = {3242749},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Time performance, benchmarking, optimisation},
}

@article{Claessen:2011:QLT:1988042.1988046,
 author = {Claessen, Koen and Hughes, John},
 title = {QuickCheck: A Lightweight Tool for Random Testing of Haskell Programs},
 journal = {SIGPLAN Not.},
 issue_date = {April 2011},
 volume = {46},
 number = {4},
 month = may,
 year = {2011},
 issn = {0362-1340},
 pages = {53--64},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/1988042.1988046},
 doi = {10.1145/1988042.1988046},
 acmid = {1988046},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@misc{pholser,
  author = {Paul Holser},
  title = {JUnit-Quickcheck},
  year = {2019},
  publisher = {GitHub},
  journal = {GitHub repository},
  howpublished = {\url{https://github.com/pholser/junit-quickcheck}},
  commit = {61e751ceb55cb767d7ef150959df0244543fcd64}
}
